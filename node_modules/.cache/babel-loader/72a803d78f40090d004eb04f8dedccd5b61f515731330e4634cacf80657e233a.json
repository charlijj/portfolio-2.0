{"ast":null,"code":"export function headerCanvas() {\n  const canvas = document.getElementById(`header-canvas`);\n  canvas.style.backgroundClip;\n  console.log(canvas);\n  console.log(\"hellow\");\n}\n\n// function playVisualizer(play) {\n\n//     const audioCtx = new AudioContext();\n//     const analyser = audioCtx.createAnalyser();\n//     const audio = new Audio(`ext/song.mp3`);\n//     const audioSource = audioCtx.createMediaElementSource(audio);\n//     audioSource.connect(analyser);\n\n//     let stop;\n\n//     if (play)\n//     {\n//         audio.play();\n//         stop = false;\n//     }\n//     else\n//     {\n//         audio.pause();\n//         stop = true;\n//     }\n\n//     //An unsigned integer, representing the window size of the FFT, given in number of samples. \n//     //A higher value will result in more details in the frequency domain but fewer details in the time domain.\n//     // Must be a power of 2 (up to 2^15)\n//     analyser.fftSize = 1024;\n\n//     //Bin count is always half of the fft size and is the number of canvas elements that are to be drawn.\n//     const bufferLen = analyser.frequencyBinCount;\n//     const dataArray = new Uint8Array(bufferLen);\n\n//     function animateFullRainbowBar() {\n\n//         if (stop)\n//         {\n//             cancelAnimationFrame(animateFullRainbowBar);\n//             window.location.reload();\n//             return;\n//         }\n\n//         const barWidth = canvas.width / bufferLen;\n//         let barHeight;\n//         let x = 0;\n//         ctx.clearRect(0, 0, canvas.width, canvas.height);\n//         analyser.getByteFrequencyData(dataArray);\n\n//         for (let i = 0; i < bufferLen; i++)\n//         {\n//             barHeight = dataArray[i] * 2;\n\n//             const hue = i * 10;\n\n//             ctx.fillStyle = `hsl(` + hue + `,100%, 50%)`;\n\n//             // let red = 100;\n//             // let blue = barHeight + 30;\n//             // let green = barHeight + 50;\n\n//             border.style.border = `3px solid hsl(` + barHeight + `,100%, 50%)`;\n//             // border.style.border = `3px solid rgb(` + red + `, ` + blue + `, ` + green + `)`;\n\n//             ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);\n\n//             ctx.save();\n//             ctx.translate(canvas.width, 0);\n//             ctx.scale(-1, 1);   \n//             ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);\n//             ctx.restore();\n\n//             x += barWidth + 5;\n\n//             if (x > canvas.width/2)\n//             {\n//                 x = 0;\n//                 break;\n//             }\n//         }\n\n//         requestAnimationFrame(animateFullRainbowBar);\n//     }\n\n//     animateFullRainbowBar(stop);\n\n// }","map":{"version":3,"names":["headerCanvas","canvas","document","getElementById","style","backgroundClip","console","log"],"sources":["/home/charlijj/Desktop/websites/portfolio_two/portfolio_two_app/src/header_script/header_script.js"],"sourcesContent":["export function headerCanvas()\n{\n    const canvas = document.getElementById(`header-canvas`);\n\n    canvas.style.backgroundClip\n    console.log(canvas)\n    console.log(\"hellow\")\n}\n\n\n\n// function playVisualizer(play) {\n\n//     const audioCtx = new AudioContext();\n//     const analyser = audioCtx.createAnalyser();\n//     const audio = new Audio(`ext/song.mp3`);\n//     const audioSource = audioCtx.createMediaElementSource(audio);\n//     audioSource.connect(analyser);\n\n//     let stop;\n\n//     if (play)\n//     {\n//         audio.play();\n//         stop = false;\n//     }\n//     else\n//     {\n//         audio.pause();\n//         stop = true;\n//     }\n\n//     //An unsigned integer, representing the window size of the FFT, given in number of samples. \n//     //A higher value will result in more details in the frequency domain but fewer details in the time domain.\n//     // Must be a power of 2 (up to 2^15)\n//     analyser.fftSize = 1024;\n\n//     //Bin count is always half of the fft size and is the number of canvas elements that are to be drawn.\n//     const bufferLen = analyser.frequencyBinCount;\n//     const dataArray = new Uint8Array(bufferLen);\n\n//     function animateFullRainbowBar() {\n\n//         if (stop)\n//         {\n//             cancelAnimationFrame(animateFullRainbowBar);\n//             window.location.reload();\n//             return;\n//         }\n\n//         const barWidth = canvas.width / bufferLen;\n//         let barHeight;\n//         let x = 0;\n//         ctx.clearRect(0, 0, canvas.width, canvas.height);\n//         analyser.getByteFrequencyData(dataArray);\n\n//         for (let i = 0; i < bufferLen; i++)\n//         {\n//             barHeight = dataArray[i] * 2;\n\n//             const hue = i * 10;\n            \n//             ctx.fillStyle = `hsl(` + hue + `,100%, 50%)`;\n\n//             // let red = 100;\n//             // let blue = barHeight + 30;\n//             // let green = barHeight + 50;\n\n//             border.style.border = `3px solid hsl(` + barHeight + `,100%, 50%)`;\n//             // border.style.border = `3px solid rgb(` + red + `, ` + blue + `, ` + green + `)`;\n\n//             ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);\n\n//             ctx.save();\n//             ctx.translate(canvas.width, 0);\n//             ctx.scale(-1, 1);   \n//             ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);\n//             ctx.restore();\n\n//             x += barWidth + 5;\n\n//             if (x > canvas.width/2)\n//             {\n//                 x = 0;\n//                 break;\n//             }\n//         }\n        \n//         requestAnimationFrame(animateFullRainbowBar);\n//     }\n\n//     animateFullRainbowBar(stop);\n\n// }"],"mappings":"AAAA,OAAO,SAASA,YAAYA,CAAA,EAC5B;EACI,MAAMC,MAAM,GAAGC,QAAQ,CAACC,cAAc,CAAE,eAAc,CAAC;EAEvDF,MAAM,CAACG,KAAK,CAACC,cAAc;EAC3BC,OAAO,CAACC,GAAG,CAACN,MAAM,CAAC;EACnBK,OAAO,CAACC,GAAG,CAAC,QAAQ,CAAC;AACzB;;AAIA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA"},"metadata":{},"sourceType":"module","externalDependencies":[]}